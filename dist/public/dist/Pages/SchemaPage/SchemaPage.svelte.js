/* src\Pages\SchemaPage\SchemaPage.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	bind,
	binding_callbacks,
	check_outros,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	set_data,
	set_style,
	space,
	text,
	transition_in,
	transition_out
} from "../../../_snowpack/pkg/svelte/internal.js";

import {
	Button,
	DataTable,
	DataTableSkeleton,
	Form,
	FormGroup,
	NumberInput,
	Toolbar,
	ToolbarBatchActions,
	ToolbarContent,
	ToolbarMenu,
	ToolbarMenuItem,
	ToolbarSearch
} from "../../../_snowpack/pkg/carbon-components-svelte.js";

import { DAQSchema, isRealtime } from "../../stores.js";
import { createModule, deleteModule, pushSchema } from "../../api.js";
import Edit24 from "../../../_snowpack/pkg/carbon-icons-svelte/lib/Edit24.js";
import Float from "../../Components/Float.svelte.js";
import ModuleDefinitionEditor from "./ModuleDefinitionEditor.svelte.js";
import { cloneDeep } from "../../../_snowpack/pkg/lodash.js";

function create_else_block_1(ctx) {
	let datatableskeleton;
	let current;
	datatableskeleton = new DataTableSkeleton({});

	return {
		c() {
			create_component(datatableskeleton.$$.fragment);
		},
		m(target, anchor) {
			mount_component(datatableskeleton, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(datatableskeleton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(datatableskeleton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(datatableskeleton, detaching);
		}
	};
}

// (46:0) {#if ($DAQSchema)}
function create_if_block(ctx) {
	let h1;
	let t0_value = /*$DAQSchema*/ ctx[2].name + "";
	let t0;
	let t1;
	let form;
	let t2;
	let datatable;
	let updating_selectedRowIds;
	let current;

	form = new Form({
			props: {
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			}
		});

	function datatable_selectedRowIds_binding(value) {
		/*datatable_selectedRowIds_binding*/ ctx[16](value);
	}

	let datatable_props = {
		expandable: true,
		headers: /*headers*/ ctx[7],
		rows: /*$DAQSchema*/ ctx[2].modules,
		title: "Modules",
		description: "Modules present in this schema",
		selectable: /*$isRealtime*/ ctx[6],
		$$slots: {
			cell: [
				create_cell_slot,
				({ cell, row }) => ({ 20: cell, 21: row }),
				({ cell, row }) => (cell ? 1048576 : 0) | (row ? 2097152 : 0)
			],
			"expanded-row": [
				create_expanded_row_slot,
				({ row }) => ({ 21: row }),
				({ row }) => row ? 2097152 : 0
			],
			default: [create_default_slot_1]
		},
		$$scope: { ctx }
	};

	if (/*selectedRowIds*/ ctx[5] !== void 0) {
		datatable_props.selectedRowIds = /*selectedRowIds*/ ctx[5];
	}

	datatable = new DataTable({ props: datatable_props });
	binding_callbacks.push(() => bind(datatable, 'selectedRowIds', datatable_selectedRowIds_binding));

	return {
		c() {
			h1 = element("h1");
			t0 = text(t0_value);
			t1 = space();
			create_component(form.$$.fragment);
			t2 = space();
			create_component(datatable.$$.fragment);
		},
		m(target, anchor) {
			insert(target, h1, anchor);
			append(h1, t0);
			insert(target, t1, anchor);
			mount_component(form, target, anchor);
			insert(target, t2, anchor);
			mount_component(datatable, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*$DAQSchema*/ 4) && t0_value !== (t0_value = /*$DAQSchema*/ ctx[2].name + "")) set_data(t0, t0_value);
			const form_changes = {};

			if (dirty & /*$$scope, frameIntervalEdited, frameIntervalValue*/ 4194307) {
				form_changes.$$scope = { dirty, ctx };
			}

			form.$set(form_changes);
			const datatable_changes = {};
			if (dirty & /*$DAQSchema*/ 4) datatable_changes.rows = /*$DAQSchema*/ ctx[2].modules;
			if (dirty & /*$isRealtime*/ 64) datatable_changes.selectable = /*$isRealtime*/ ctx[6];

			if (dirty & /*$$scope, cell, row*/ 7340032) {
				datatable_changes.$$scope = { dirty, ctx };
			}

			if (!updating_selectedRowIds && dirty & /*selectedRowIds*/ 32) {
				updating_selectedRowIds = true;
				datatable_changes.selectedRowIds = /*selectedRowIds*/ ctx[5];
				add_flush_callback(() => updating_selectedRowIds = false);
			}

			datatable.$set(datatable_changes);
		},
		i(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			transition_in(datatable.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(form.$$.fragment, local);
			transition_out(datatable.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h1);
			if (detaching) detach(t1);
			destroy_component(form, detaching);
			if (detaching) detach(t2);
			destroy_component(datatable, detaching);
		}
	};
}

// (57:12) <Button on:click={applyFrameInterval} disabled={!frameIntervalEdited}>
function create_default_slot_11(ctx) {
	let t;

	return {
		c() {
			t = text("Apply");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (49:8) <FormGroup style="display: flex; flex-direction: row; align-items: center; gap: 1rem">
function create_default_slot_10(ctx) {
	let numberinput;
	let updating_value;
	let t;
	let button;
	let current;

	function numberinput_value_binding(value) {
		/*numberinput_value_binding*/ ctx[13](value);
	}

	let numberinput_props = {
		label: "Framerate",
		helperText: "How often a data \"frame\" is captured, in hz"
	};

	if (/*frameIntervalValue*/ ctx[0] !== void 0) {
		numberinput_props.value = /*frameIntervalValue*/ ctx[0];
	}

	numberinput = new NumberInput({ props: numberinput_props });
	binding_callbacks.push(() => bind(numberinput, 'value', numberinput_value_binding));
	numberinput.$on("input", /*onFrameIntervalInput*/ ctx[10]);

	button = new Button({
			props: {
				disabled: !/*frameIntervalEdited*/ ctx[1],
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*applyFrameInterval*/ ctx[11]);

	return {
		c() {
			create_component(numberinput.$$.fragment);
			t = space();
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(numberinput, target, anchor);
			insert(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const numberinput_changes = {};

			if (!updating_value && dirty & /*frameIntervalValue*/ 1) {
				updating_value = true;
				numberinput_changes.value = /*frameIntervalValue*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			numberinput.$set(numberinput_changes);
			const button_changes = {};
			if (dirty & /*frameIntervalEdited*/ 2) button_changes.disabled = !/*frameIntervalEdited*/ ctx[1];

			if (dirty & /*$$scope*/ 4194304) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(numberinput.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(numberinput.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(numberinput, detaching);
			if (detaching) detach(t);
			destroy_component(button, detaching);
		}
	};
}

// (48:4) <Form>
function create_default_slot_9(ctx) {
	let formgroup;
	let current;

	formgroup = new FormGroup({
			props: {
				style: "display: flex; flex-direction: row; align-items: center; gap: 1rem",
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(formgroup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(formgroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const formgroup_changes = {};

			if (dirty & /*$$scope, frameIntervalEdited, frameIntervalValue*/ 4194307) {
				formgroup_changes.$$scope = { dirty, ctx };
			}

			formgroup.$set(formgroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(formgroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(formgroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(formgroup, detaching);
		}
	};
}

// (93:16) <Button kind="danger" on:click={deleteSelected}>
function create_default_slot_8(ctx) {
	let t;

	return {
		c() {
			t = text("Delete");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (92:12) <ToolbarBatchActions>
function create_default_slot_7(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				kind: "danger",
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*deleteSelected*/ ctx[9]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 4194304) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (99:20) <ToolbarMenuItem primaryFocus>
function create_default_slot_6(ctx) {
	let t;

	return {
		c() {
			t = text("Reload (TODO)");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (98:16) <ToolbarMenu>
function create_default_slot_5(ctx) {
	let toolbarmenuitem;
	let current;

	toolbarmenuitem = new ToolbarMenuItem({
			props: {
				primaryFocus: true,
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(toolbarmenuitem.$$.fragment);
		},
		m(target, anchor) {
			mount_component(toolbarmenuitem, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toolbarmenuitem_changes = {};

			if (dirty & /*$$scope*/ 4194304) {
				toolbarmenuitem_changes.$$scope = { dirty, ctx };
			}

			toolbarmenuitem.$set(toolbarmenuitem_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toolbarmenuitem.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toolbarmenuitem.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(toolbarmenuitem, detaching);
		}
	};
}

// (101:16) <Button on:click={() => createModule("blank_module")}>
function create_default_slot_4(ctx) {
	let t;

	return {
		c() {
			t = text("Create module");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (96:12) <ToolbarContent>
function create_default_slot_3(ctx) {
	let toolbarsearch;
	let t0;
	let toolbarmenu;
	let t1;
	let button;
	let current;
	toolbarsearch = new ToolbarSearch({});

	toolbarmenu = new ToolbarMenu({
			props: {
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			}
		});

	button = new Button({
			props: {
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler_1*/ ctx[15]);

	return {
		c() {
			create_component(toolbarsearch.$$.fragment);
			t0 = space();
			create_component(toolbarmenu.$$.fragment);
			t1 = space();
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(toolbarsearch, target, anchor);
			insert(target, t0, anchor);
			mount_component(toolbarmenu, target, anchor);
			insert(target, t1, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toolbarmenu_changes = {};

			if (dirty & /*$$scope*/ 4194304) {
				toolbarmenu_changes.$$scope = { dirty, ctx };
			}

			toolbarmenu.$set(toolbarmenu_changes);
			const button_changes = {};

			if (dirty & /*$$scope*/ 4194304) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toolbarsearch.$$.fragment, local);
			transition_in(toolbarmenu.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toolbarsearch.$$.fragment, local);
			transition_out(toolbarmenu.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(toolbarsearch, detaching);
			if (detaching) detach(t0);
			destroy_component(toolbarmenu, detaching);
			if (detaching) detach(t1);
			destroy_component(button, detaching);
		}
	};
}

// (91:8) <Toolbar>
function create_default_slot_2(ctx) {
	let toolbarbatchactions;
	let t;
	let toolbarcontent;
	let current;

	toolbarbatchactions = new ToolbarBatchActions({
			props: {
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			}
		});

	toolbarcontent = new ToolbarContent({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(toolbarbatchactions.$$.fragment);
			t = space();
			create_component(toolbarcontent.$$.fragment);
		},
		m(target, anchor) {
			mount_component(toolbarbatchactions, target, anchor);
			insert(target, t, anchor);
			mount_component(toolbarcontent, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toolbarbatchactions_changes = {};

			if (dirty & /*$$scope*/ 4194304) {
				toolbarbatchactions_changes.$$scope = { dirty, ctx };
			}

			toolbarbatchactions.$set(toolbarbatchactions_changes);
			const toolbarcontent_changes = {};

			if (dirty & /*$$scope*/ 4194304) {
				toolbarcontent_changes.$$scope = { dirty, ctx };
			}

			toolbarcontent.$set(toolbarcontent_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toolbarbatchactions.$$.fragment, local);
			transition_in(toolbarcontent.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toolbarbatchactions.$$.fragment, local);
			transition_out(toolbarcontent.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(toolbarbatchactions, detaching);
			if (detaching) detach(t);
			destroy_component(toolbarcontent, detaching);
		}
	};
}

// (63:4) <DataTable              expandable              headers={headers}              rows={$DAQSchema.modules}              title="Modules"              description="Modules present in this schema"              selectable={$isRealtime}              bind:selectedRowIds      >
function create_default_slot_1(ctx) {
	let toolbar;
	let current;

	toolbar = new Toolbar({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(toolbar.$$.fragment);
		},
		m(target, anchor) {
			mount_component(toolbar, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toolbar_changes = {};

			if (dirty & /*$$scope*/ 4194304) {
				toolbar_changes.$$scope = { dirty, ctx };
			}

			toolbar.$set(toolbar_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toolbar.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toolbar.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(toolbar, detaching);
		}
	};
}

// (72:8) <svelte:fragment slot="expanded-row" let:row>
function create_expanded_row_slot(ctx) {
	let span;
	let t_value = (/*row*/ ctx[21].description || "No description") + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
			set_style(span, "white-space", "pre ");
			set_style(span, "display", "block");
			set_style(span, "unicode-bidi", "embed");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*row*/ 2097152 && t_value !== (t_value = (/*row*/ ctx[21].description || "No description") + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (88:12) {:else}
function create_else_block(ctx) {
	let t_value = /*cell*/ ctx[20].value + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*cell*/ 1048576 && t_value !== (t_value = /*cell*/ ctx[20].value + "")) set_data(t, t_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (79:12) {#if cell.key === "overflow"}
function create_if_block_1(ctx) {
	let float;
	let current;

	float = new Float({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(float.$$.fragment);
		},
		m(target, anchor) {
			mount_component(float, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const float_changes = {};

			if (dirty & /*$$scope*/ 4194304) {
				float_changes.$$scope = { dirty, ctx };
			}

			float.$set(float_changes);
		},
		i(local) {
			if (current) return;
			transition_in(float.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(float.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(float, detaching);
		}
	};
}

// (80:16) <Float>
function create_default_slot(ctx) {
	let button;
	let current;

	function click_handler() {
		return /*click_handler*/ ctx[14](/*row*/ ctx[21]);
	}

	button = new Button({
			props: {
				icon: Edit24,
				iconDescription: "Edit Module",
				tooltipPosition: "left",
				tooltipAlignment: "start",
				kind: "ghost"
			}
		});

	button.$on("click", click_handler);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (78:8) <svelte:fragment slot="cell" let:cell let:row>
function create_cell_slot(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*cell*/ ctx[20].key === "overflow") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let t;
	let moduledefinitioneditor;
	let updating_open;
	let updating_id;
	let current;
	const if_block_creators = [create_if_block, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$DAQSchema*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	function moduledefinitioneditor_open_binding(value) {
		/*moduledefinitioneditor_open_binding*/ ctx[17](value);
	}

	function moduledefinitioneditor_id_binding(value) {
		/*moduledefinitioneditor_id_binding*/ ctx[18](value);
	}

	let moduledefinitioneditor_props = {};

	if (/*editModalOpen*/ ctx[3] !== void 0) {
		moduledefinitioneditor_props.open = /*editModalOpen*/ ctx[3];
	}

	if (/*editId*/ ctx[4] !== void 0) {
		moduledefinitioneditor_props.id = /*editId*/ ctx[4];
	}

	moduledefinitioneditor = new ModuleDefinitionEditor({ props: moduledefinitioneditor_props });
	binding_callbacks.push(() => bind(moduledefinitioneditor, 'open', moduledefinitioneditor_open_binding));
	binding_callbacks.push(() => bind(moduledefinitioneditor, 'id', moduledefinitioneditor_id_binding));

	return {
		c() {
			if_block.c();
			t = space();
			create_component(moduledefinitioneditor.$$.fragment);
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, t, anchor);
			mount_component(moduledefinitioneditor, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(t.parentNode, t);
			}

			const moduledefinitioneditor_changes = {};

			if (!updating_open && dirty & /*editModalOpen*/ 8) {
				updating_open = true;
				moduledefinitioneditor_changes.open = /*editModalOpen*/ ctx[3];
				add_flush_callback(() => updating_open = false);
			}

			if (!updating_id && dirty & /*editId*/ 16) {
				updating_id = true;
				moduledefinitioneditor_changes.id = /*editId*/ ctx[4];
				add_flush_callback(() => updating_id = false);
			}

			moduledefinitioneditor.$set(moduledefinitioneditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(moduledefinitioneditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(moduledefinitioneditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(t);
			destroy_component(moduledefinitioneditor, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $DAQSchema;
	let $isRealtime;
	component_subscribe($$self, DAQSchema, $$value => $$invalidate(2, $DAQSchema = $$value));
	component_subscribe($$self, isRealtime, $$value => $$invalidate(6, $isRealtime = $$value));
	var _a;
	let editModalOpen = false;
	let editId;
	let editsMade = false;
	let selectedRowIds = [];
	let frameIntervalValue = 0;
	let frameIntervalEdited = false;

	const headers = [
		{ key: "name", value: "Name" },
		{ key: "type", value: "Type" },
		{ key: "mac", value: "MAC Address" },
		{ key: "overflow", empty: true }
	]; // {key: "version", value: "Version"},

	function openEditModal(moduleId) {
		$$invalidate(4, editId = moduleId);
		$$invalidate(3, editModalOpen = true);
		editsMade = false;
	}

	function deleteSelected() {
		deleteModule(selectedRowIds);
		$$invalidate(5, selectedRowIds = []);
	}

	function onFrameIntervalInput(e) {
		$$invalidate(1, frameIntervalEdited = true);
	}

	function applyFrameInterval() {
		$$invalidate(1, frameIntervalEdited = false);
		let s = cloneDeep($DAQSchema);
		s.frameInterval = 1000 / frameIntervalValue | 0;
		pushSchema(s);
	}

	function numberinput_value_binding(value) {
		frameIntervalValue = value;
		((($$invalidate(0, frameIntervalValue), $$invalidate(1, frameIntervalEdited)), $$invalidate(2, $DAQSchema)), $$invalidate(12, _a));
	}

	const click_handler = row => openEditModal(row.id);
	const click_handler_1 = () => createModule("blank_module");

	function datatable_selectedRowIds_binding(value) {
		selectedRowIds = value;
		$$invalidate(5, selectedRowIds);
	}

	function moduledefinitioneditor_open_binding(value) {
		editModalOpen = value;
		$$invalidate(3, editModalOpen);
	}

	function moduledefinitioneditor_id_binding(value) {
		editId = value;
		$$invalidate(4, editId);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*frameIntervalEdited, $DAQSchema, _a*/ 4102) {
			$: if (!frameIntervalEdited) $$invalidate(0, frameIntervalValue = 1000 / ($$invalidate(12, _a = $DAQSchema === null || $DAQSchema === void 0
			? void 0
			: $DAQSchema.frameInterval) !== null && _a !== void 0
			? _a
			: 1) | 0);
		}

		if ($$self.$$.dirty & /*frameIntervalValue*/ 1) {
			$: console.log(frameIntervalValue);
		}
	};

	return [
		frameIntervalValue,
		frameIntervalEdited,
		$DAQSchema,
		editModalOpen,
		editId,
		selectedRowIds,
		$isRealtime,
		headers,
		openEditModal,
		deleteSelected,
		onFrameIntervalInput,
		applyFrameInterval,
		_a,
		numberinput_value_binding,
		click_handler,
		click_handler_1,
		datatable_selectedRowIds_binding,
		moduledefinitioneditor_open_binding,
		moduledefinitioneditor_id_binding
	];
}

class SchemaPage extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default SchemaPage;