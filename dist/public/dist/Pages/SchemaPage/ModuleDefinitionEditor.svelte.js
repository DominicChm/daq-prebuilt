/* src\Pages\SchemaPage\ModuleDefinitionEditor.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	bind,
	binding_callbacks,
	check_outros,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	set_data,
	space,
	text,
	transition_in,
	transition_out
} from "../../../_snowpack/pkg/svelte/internal.js";

import {
	Form,
	FormGroup,
	Modal,
	TextArea,
	TextInput
} from "../../../_snowpack/pkg/carbon-components-svelte.js";

import { createEventDispatcher } from "../../../_snowpack/pkg/svelte.js";
import { cloneDeep } from "../../../_snowpack/pkg/lodash.js";
import { DAQSchema } from "../../stores.js";
import { applyModuleDefinition } from "../../api.js";
import ModuleConfig from "../../ModuleWidgets/ModuleConfig.svelte.js";

function create_else_block(ctx) {
	let p0;
	let t1;
	let p1;
	let t2;
	let t3;

	return {
		c() {
			p0 = element("p");
			p0.textContent = "No data. This module might have been deleted.";
			t1 = space();
			p1 = element("p");
			t2 = text("ID: ");
			t3 = text(/*id*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, p0, anchor);
			insert(target, t1, anchor);
			insert(target, p1, anchor);
			append(p1, t2);
			append(p1, t3);
		},
		p(ctx, dirty) {
			if (dirty & /*id*/ 2) set_data(t3, /*id*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(p0);
			if (detaching) detach(t1);
			if (detaching) detach(p1);
		}
	};
}

// (54:4) {#if (editCache && id)}
function create_if_block(ctx) {
	let show_if = /*editCache*/ ctx[2]?.config && Object.keys(/*editCache*/ ctx[2].config).length > 0;
	let if_block_anchor;
	let current;
	let if_block = show_if && create_if_block_1(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*editCache*/ 4) show_if = /*editCache*/ ctx[2]?.config && Object.keys(/*editCache*/ ctx[2].config).length > 0;

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*editCache*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (55:8) {#if (editCache?.config && Object.keys(editCache.config).length > 0)}
function create_if_block_1(ctx) {
	let moduleconfig;
	let updating_definition;
	let current;

	function moduleconfig_definition_binding(value) {
		/*moduleconfig_definition_binding*/ ctx[9](value);
	}

	let moduleconfig_props = { typename: /*editCache*/ ctx[2].type };

	if (/*editCache*/ ctx[2] !== void 0) {
		moduleconfig_props.definition = /*editCache*/ ctx[2];
	}

	moduleconfig = new ModuleConfig({ props: moduleconfig_props });
	binding_callbacks.push(() => bind(moduleconfig, 'definition', moduleconfig_definition_binding));
	moduleconfig.$on("input", /*changeMade*/ ctx[6]);
	moduleconfig.$on("focus", /*focus_handler*/ ctx[10]);
	moduleconfig.$on("blur", /*blur_handler*/ ctx[11]);

	return {
		c() {
			create_component(moduleconfig.$$.fragment);
		},
		m(target, anchor) {
			mount_component(moduleconfig, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const moduleconfig_changes = {};
			if (dirty & /*editCache*/ 4) moduleconfig_changes.typename = /*editCache*/ ctx[2].type;

			if (!updating_definition && dirty & /*editCache*/ 4) {
				updating_definition = true;
				moduleconfig_changes.definition = /*editCache*/ ctx[2];
				add_flush_callback(() => updating_definition = false);
			}

			moduleconfig.$set(moduleconfig_changes);
		},
		i(local) {
			if (current) return;
			transition_in(moduleconfig.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(moduleconfig.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(moduleconfig, detaching);
		}
	};
}

// (44:0) <Modal          bind:open          modalHeading="Edit Module"          primaryButtonText="Apply"          secondaryButtonText="Cancel"          primaryButtonDisabled={!editsMade}          on:submit={applyEdits}          on:click:button--secondary={() => open = false}          hasScrollingContent          shouldSubmitOnEnter={closeOnEnter}>
function create_default_slot(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*editCache*/ ctx[2] && /*id*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment(ctx) {
	let modal;
	let updating_open;
	let current;

	function modal_open_binding(value) {
		/*modal_open_binding*/ ctx[12](value);
	}

	let modal_props = {
		modalHeading: "Edit Module",
		primaryButtonText: "Apply",
		secondaryButtonText: "Cancel",
		primaryButtonDisabled: !/*editsMade*/ ctx[3],
		hasScrollingContent: true,
		shouldSubmitOnEnter: /*closeOnEnter*/ ctx[4],
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*open*/ ctx[0] !== void 0) {
		modal_props.open = /*open*/ ctx[0];
	}

	modal = new Modal({ props: modal_props });
	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));
	modal.$on("submit", /*applyEdits*/ ctx[5]);
	modal.$on("click:button--secondary", /*click_button_secondary_handler*/ ctx[13]);

	return {
		c() {
			create_component(modal.$$.fragment);
		},
		m(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const modal_changes = {};
			if (dirty & /*editsMade*/ 8) modal_changes.primaryButtonDisabled = !/*editsMade*/ ctx[3];
			if (dirty & /*closeOnEnter*/ 16) modal_changes.shouldSubmitOnEnter = /*closeOnEnter*/ ctx[4];

			if (dirty & /*$$scope, editCache, closeOnEnter, id*/ 65558) {
				modal_changes.$$scope = { dirty, ctx };
			}

			if (!updating_open && dirty & /*open*/ 1) {
				updating_open = true;
				modal_changes.open = /*open*/ ctx[0];
				add_flush_callback(() => updating_open = false);
			}

			modal.$set(modal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(modal, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $DAQSchema;
	component_subscribe($$self, DAQSchema, $$value => $$invalidate(8, $DAQSchema = $$value));
	const dispatch = createEventDispatcher();
	let { open = false } = $$props;
	let { id = null } = $$props;
	let editCache = null;
	let cacheInvalid = true;
	let n = { n: "" };
	let editsMade;
	let closeOnEnter = true;

	function applyEdits() {
		applyModuleDefinition(editCache);
		$$invalidate(0, open = false);
	}

	function changeMade() {
		$$invalidate(3, editsMade = true);
	}

	function moduleconfig_definition_binding(value) {
		editCache = value;
		(((($$invalidate(2, editCache), $$invalidate(8, $DAQSchema)), $$invalidate(7, cacheInvalid)), $$invalidate(0, open)), $$invalidate(1, id));
	}

	const focus_handler = () => $$invalidate(4, closeOnEnter = false);
	const blur_handler = () => $$invalidate(4, closeOnEnter = true);

	function modal_open_binding(value) {
		open = value;
		$$invalidate(0, open);
	}

	const click_button_secondary_handler = () => $$invalidate(0, open = false);

	$$self.$$set = $$props => {
		if ('open' in $$props) $$invalidate(0, open = $$props.open);
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*open*/ 1) {
			$: if (open) $$invalidate(3, editsMade = false);
		}

		if ($$self.$$.dirty & /*open*/ 1) {
			$: if (!open) $$invalidate(7, cacheInvalid = true);
		}

		if ($$self.$$.dirty & /*$DAQSchema, cacheInvalid, open, id*/ 387) {
			$: {
				if ($DAQSchema && cacheInvalid && open) {
					$$invalidate(2, editCache = cloneDeep($DAQSchema.modules.find(m => m.id === id)));
					$$invalidate(7, cacheInvalid = false);
				}
			}
		}
	};

	return [
		open,
		id,
		editCache,
		editsMade,
		closeOnEnter,
		applyEdits,
		changeMade,
		cacheInvalid,
		$DAQSchema,
		moduleconfig_definition_binding,
		focus_handler,
		blur_handler,
		modal_open_binding,
		click_button_secondary_handler
	];
}

class ModuleDefinitionEditor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { open: 0, id: 1 });
	}
}

export default ModuleDefinitionEditor;