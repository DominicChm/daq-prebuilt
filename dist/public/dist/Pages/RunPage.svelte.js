/* src\Pages\RunPage.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	bind,
	binding_callbacks,
	check_outros,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	set_data,
	set_style,
	space,
	text,
	transition_in,
	transition_out
} from "../../_snowpack/pkg/svelte/internal.js";

import {
	Button,
	DataTable,
	DataTableSkeleton,
	Form,
	FormGroup,
	Modal,
	OverflowMenu,
	OverflowMenuItem,
	TextArea,
	TextInput,
	Toolbar,
	ToolbarContent
} from "../../_snowpack/pkg/carbon-components-svelte.js";

import {
	activeRun,
	activeRunId,
	connected,
	isRealtime,
	recordingRun,
	runs
} from "../stores.js";

import { activateRun, deactivateRun, deleteRun, setRunMetadata } from "../api.js";
import Float from "../Components/Float.svelte.js";
import TrashCan24 from "../../_snowpack/pkg/carbon-icons-svelte/lib/TrashCan24.js";
import { cloneDeep } from "../../_snowpack/pkg/lodash.js";
import RecordButton from "../Components/RecordButton.svelte.js";
import { push } from "../../_snowpack/pkg/svelte-spa-router.js";
import { config } from "../config.js";

function create_else_block_1(ctx) {
	let datatableskeleton;
	let current;
	datatableskeleton = new DataTableSkeleton({ props: { showToolbar: false } });

	return {
		c() {
			create_component(datatableskeleton.$$.fragment);
		},
		m(target, anchor) {
			mount_component(datatableskeleton, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(datatableskeleton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(datatableskeleton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(datatableskeleton, detaching);
		}
	};
}

// (64:0) {#if ($connected)}
function create_if_block_1(ctx) {
	let datatable;
	let updating_selectedRowIds;
	let current;

	function datatable_selectedRowIds_binding(value) {
		/*datatable_selectedRowIds_binding*/ ctx[15](value);
	}

	let datatable_props = {
		title: "Runs",
		description: "All available runs",
		headers: /*headers*/ ctx[8],
		rows: /*$runs*/ ctx[5],
		radio: true,
		expandable: true,
		$$slots: {
			cell: [
				create_cell_slot,
				({ cell, row }) => ({ 25: cell, 26: row }),
				({ cell, row }) => (cell ? 33554432 : 0) | (row ? 67108864 : 0)
			],
			"expanded-row": [
				create_expanded_row_slot,
				({ row }) => ({ 26: row }),
				({ row }) => row ? 67108864 : 0
			],
			default: [create_default_slot_5]
		},
		$$scope: { ctx }
	};

	if (/*selectedRowIds*/ ctx[0] !== void 0) {
		datatable_props.selectedRowIds = /*selectedRowIds*/ ctx[0];
	}

	datatable = new DataTable({ props: datatable_props });
	binding_callbacks.push(() => bind(datatable, 'selectedRowIds', datatable_selectedRowIds_binding));
	datatable.$on("click:row", /*click_row_handler*/ ctx[16]);

	return {
		c() {
			create_component(datatable.$$.fragment);
		},
		m(target, anchor) {
			mount_component(datatable, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const datatable_changes = {};
			if (dirty & /*$runs*/ 32) datatable_changes.rows = /*$runs*/ ctx[5];

			if (dirty & /*$$scope, row, cell*/ 234881024) {
				datatable_changes.$$scope = { dirty, ctx };
			}

			if (!updating_selectedRowIds && dirty & /*selectedRowIds*/ 1) {
				updating_selectedRowIds = true;
				datatable_changes.selectedRowIds = /*selectedRowIds*/ ctx[0];
				add_flush_callback(() => updating_selectedRowIds = false);
			}

			datatable.$set(datatable_changes);
		},
		i(local) {
			if (current) return;
			transition_in(datatable.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(datatable.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(datatable, detaching);
		}
	};
}

// (101:16) <Button on:click={deactivateRun} kind="secondary">
function create_default_slot_8(ctx) {
	let t;

	return {
		c() {
			t = text("Deactivate");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (100:12) <ToolbarContent>
function create_default_slot_7(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				kind: "secondary",
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			}
		});

	button.$on("click", deactivateRun);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 134217728) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (99:8) <Toolbar>
function create_default_slot_6(ctx) {
	let toolbarcontent;
	let current;

	toolbarcontent = new ToolbarContent({
			props: {
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(toolbarcontent.$$.fragment);
		},
		m(target, anchor) {
			mount_component(toolbarcontent, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toolbarcontent_changes = {};

			if (dirty & /*$$scope*/ 134217728) {
				toolbarcontent_changes.$$scope = { dirty, ctx };
			}

			toolbarcontent.$set(toolbarcontent_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toolbarcontent.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toolbarcontent.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(toolbarcontent, detaching);
		}
	};
}

// (65:4) <DataTable              title="Runs"              description="All available runs"              headers={headers}              rows={$runs}              radio              expandable              bind:selectedRowIds={selectedRowIds}              on:click:row={(e) => activateRun(e.detail.id)}>
function create_default_slot_5(ctx) {
	let toolbar;
	let current;

	toolbar = new Toolbar({
			props: {
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(toolbar.$$.fragment);
		},
		m(target, anchor) {
			mount_component(toolbar, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toolbar_changes = {};

			if (dirty & /*$$scope*/ 134217728) {
				toolbar_changes.$$scope = { dirty, ctx };
			}

			toolbar.$set(toolbar_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toolbar.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toolbar.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(toolbar, detaching);
		}
	};
}

// (74:8) <svelte:fragment slot="expanded-row" let:row>
function create_expanded_row_slot(ctx) {
	let span;
	let t0_value = /*row*/ ctx[26].id + "\n" + "";
	let t0;
	let t1;
	let t2_value = (/*row*/ ctx[26].meta.description || "No description") + "";
	let t2;

	return {
		c() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			t2 = text(t2_value);
			set_style(span, "white-space", "pre ");
			set_style(span, "display", "block");
			set_style(span, "unicode-bidi", "embed");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			append(span, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*row*/ 67108864 && t0_value !== (t0_value = /*row*/ ctx[26].id + "\n" + "")) set_data(t0, t0_value);
			if (dirty & /*row*/ 67108864 && t2_value !== (t2_value = (/*row*/ ctx[26].meta.description || "No description") + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (95:12) {:else}
function create_else_block(ctx) {
	let t_value = /*cell*/ ctx[25].value + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*cell*/ 33554432 && t_value !== (t_value = /*cell*/ ctx[25].value + "")) set_data(t, t_value);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (82:12) {#if cell.key === "overflow"}
function create_if_block_2(ctx) {
	let float;
	let current;

	float = new Float({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(float.$$.fragment);
		},
		m(target, anchor) {
			mount_component(float, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const float_changes = {};

			if (dirty & /*$$scope, row*/ 201326592) {
				float_changes.$$scope = { dirty, ctx };
			}

			float.$set(float_changes);
		},
		i(local) {
			if (current) return;
			transition_in(float.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(float.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(float, detaching);
		}
	};
}

// (91:56) 
function create_if_block_4(ctx) {
	let recordbutton;
	let current;
	recordbutton = new RecordButton({ props: { id: /*row*/ ctx[26].id } });

	return {
		c() {
			create_component(recordbutton.$$.fragment);
		},
		m(target, anchor) {
			mount_component(recordbutton, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const recordbutton_changes = {};
			if (dirty & /*row*/ 67108864) recordbutton_changes.id = /*row*/ ctx[26].id;
			recordbutton.$set(recordbutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in(recordbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(recordbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(recordbutton, detaching);
		}
	};
}

// (84:20) {#if (row.type !== "realtime")}
function create_if_block_3(ctx) {
	let overflowmenu;
	let current;

	overflowmenu = new OverflowMenu({
			props: {
				flipped: true,
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(overflowmenu.$$.fragment);
		},
		m(target, anchor) {
			mount_component(overflowmenu, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const overflowmenu_changes = {};

			if (dirty & /*$$scope*/ 134217728) {
				overflowmenu_changes.$$scope = { dirty, ctx };
			}

			overflowmenu.$set(overflowmenu_changes);
		},
		i(local) {
			if (current) return;
			transition_in(overflowmenu.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(overflowmenu.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(overflowmenu, detaching);
		}
	};
}

// (85:24) <OverflowMenu flipped>
function create_default_slot_4(ctx) {
	let overflowmenuitem0;
	let t0;
	let overflowmenuitem1;
	let t1;
	let overflowmenuitem2;
	let current;

	function click_handler() {
		return /*click_handler*/ ctx[12](/*row*/ ctx[26]);
	}

	overflowmenuitem0 = new OverflowMenuItem({ props: { text: "Edit" } });
	overflowmenuitem0.$on("click", click_handler);

	function click_handler_1() {
		return /*click_handler_1*/ ctx[13](/*row*/ ctx[26]);
	}

	overflowmenuitem1 = new OverflowMenuItem({ props: { text: "Download CSV" } });
	overflowmenuitem1.$on("click", click_handler_1);

	function click_handler_2() {
		return /*click_handler_2*/ ctx[14](/*row*/ ctx[26]);
	}

	overflowmenuitem2 = new OverflowMenuItem({ props: { danger: true, text: "Delete" } });
	overflowmenuitem2.$on("click", click_handler_2);

	return {
		c() {
			create_component(overflowmenuitem0.$$.fragment);
			t0 = space();
			create_component(overflowmenuitem1.$$.fragment);
			t1 = space();
			create_component(overflowmenuitem2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(overflowmenuitem0, target, anchor);
			insert(target, t0, anchor);
			mount_component(overflowmenuitem1, target, anchor);
			insert(target, t1, anchor);
			mount_component(overflowmenuitem2, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i(local) {
			if (current) return;
			transition_in(overflowmenuitem0.$$.fragment, local);
			transition_in(overflowmenuitem1.$$.fragment, local);
			transition_in(overflowmenuitem2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(overflowmenuitem0.$$.fragment, local);
			transition_out(overflowmenuitem1.$$.fragment, local);
			transition_out(overflowmenuitem2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(overflowmenuitem0, detaching);
			if (detaching) detach(t0);
			destroy_component(overflowmenuitem1, detaching);
			if (detaching) detach(t1);
			destroy_component(overflowmenuitem2, detaching);
		}
	};
}

// (83:16) <Float>
function create_default_slot_3(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_3, create_if_block_4];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*row*/ ctx[26].type !== "realtime") return 0;
		if (/*row*/ ctx[26].type === "realtime") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_2(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (81:8) <svelte:fragment slot="cell" let:cell let:row>
function create_cell_slot(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_2, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*cell*/ ctx[25].key === "overflow") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (119:4) {#if editCache}
function create_if_block(ctx) {
	let form;
	let current;

	form = new Form({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(form.$$.fragment);
		},
		m(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const form_changes = {};

			if (dirty & /*$$scope, editCache, closeOnEnter*/ 134217748) {
				form_changes.$$scope = { dirty, ctx };
			}

			form.$set(form_changes);
		},
		i(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(form, detaching);
		}
	};
}

// (121:12) <FormGroup>
function create_default_slot_2(ctx) {
	let textinput;
	let updating_value;
	let t;
	let textarea;
	let updating_value_1;
	let current;

	function textinput_value_binding(value) {
		/*textinput_value_binding*/ ctx[17](value);
	}

	let textinput_props = { labelText: "Name" };

	if (/*editCache*/ ctx[2].meta.name !== void 0) {
		textinput_props.value = /*editCache*/ ctx[2].meta.name;
	}

	textinput = new TextInput({ props: textinput_props });
	binding_callbacks.push(() => bind(textinput, 'value', textinput_value_binding));
	textinput.$on("input", /*changesMade*/ ctx[7]);

	function textarea_value_binding(value) {
		/*textarea_value_binding*/ ctx[18](value);
	}

	let textarea_props = { labelText: "Description" };

	if (/*editCache*/ ctx[2].meta.description !== void 0) {
		textarea_props.value = /*editCache*/ ctx[2].meta.description;
	}

	textarea = new TextArea({ props: textarea_props });
	binding_callbacks.push(() => bind(textarea, 'value', textarea_value_binding));
	textarea.$on("input", /*changesMade*/ ctx[7]);
	textarea.$on("focus", /*focus_handler*/ ctx[19]);
	textarea.$on("blur", /*blur_handler*/ ctx[20]);

	return {
		c() {
			create_component(textinput.$$.fragment);
			t = space();
			create_component(textarea.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textinput, target, anchor);
			insert(target, t, anchor);
			mount_component(textarea, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textinput_changes = {};

			if (!updating_value && dirty & /*editCache*/ 4) {
				updating_value = true;
				textinput_changes.value = /*editCache*/ ctx[2].meta.name;
				add_flush_callback(() => updating_value = false);
			}

			textinput.$set(textinput_changes);
			const textarea_changes = {};

			if (!updating_value_1 && dirty & /*editCache*/ 4) {
				updating_value_1 = true;
				textarea_changes.value = /*editCache*/ ctx[2].meta.description;
				add_flush_callback(() => updating_value_1 = false);
			}

			textarea.$set(textarea_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textinput.$$.fragment, local);
			transition_in(textarea.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textinput.$$.fragment, local);
			transition_out(textarea.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textinput, detaching);
			if (detaching) detach(t);
			destroy_component(textarea, detaching);
		}
	};
}

// (120:8) <Form>
function create_default_slot_1(ctx) {
	let formgroup;
	let current;

	formgroup = new FormGroup({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(formgroup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(formgroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const formgroup_changes = {};

			if (dirty & /*$$scope, editCache, closeOnEnter*/ 134217748) {
				formgroup_changes.$$scope = { dirty, ctx };
			}

			formgroup.$set(formgroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(formgroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(formgroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(formgroup, detaching);
		}
	};
}

// (110:0) <Modal          bind:open={editOpen}          primaryButtonText="Apply"          secondaryButtonText="Cancel"          primaryButtonDisabled={!wereChangesMade}          modalHeading="Edit Run"          on:submit={applyEdits}          bind:shouldSubmitOnEnter={closeOnEnter}          on:click:button--secondary={() => editOpen = false}>
function create_default_slot(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*editCache*/ ctx[2] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*editCache*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*editCache*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let t;
	let modal;
	let updating_open;
	let updating_shouldSubmitOnEnter;
	let current;
	const if_block_creators = [create_if_block_1, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$connected*/ ctx[6]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	function modal_open_binding(value) {
		/*modal_open_binding*/ ctx[21](value);
	}

	function modal_shouldSubmitOnEnter_binding(value) {
		/*modal_shouldSubmitOnEnter_binding*/ ctx[22](value);
	}

	let modal_props = {
		primaryButtonText: "Apply",
		secondaryButtonText: "Cancel",
		primaryButtonDisabled: !/*wereChangesMade*/ ctx[3],
		modalHeading: "Edit Run",
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*editOpen*/ ctx[1] !== void 0) {
		modal_props.open = /*editOpen*/ ctx[1];
	}

	if (/*closeOnEnter*/ ctx[4] !== void 0) {
		modal_props.shouldSubmitOnEnter = /*closeOnEnter*/ ctx[4];
	}

	modal = new Modal({ props: modal_props });
	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));
	binding_callbacks.push(() => bind(modal, 'shouldSubmitOnEnter', modal_shouldSubmitOnEnter_binding));
	modal.$on("submit", /*applyEdits*/ ctx[10]);
	modal.$on("click:button--secondary", /*click_button_secondary_handler*/ ctx[23]);

	return {
		c() {
			if_block.c();
			t = space();
			create_component(modal.$$.fragment);
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, t, anchor);
			mount_component(modal, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(t.parentNode, t);
			}

			const modal_changes = {};
			if (dirty & /*wereChangesMade*/ 8) modal_changes.primaryButtonDisabled = !/*wereChangesMade*/ ctx[3];

			if (dirty & /*$$scope, editCache, closeOnEnter*/ 134217748) {
				modal_changes.$$scope = { dirty, ctx };
			}

			if (!updating_open && dirty & /*editOpen*/ 2) {
				updating_open = true;
				modal_changes.open = /*editOpen*/ ctx[1];
				add_flush_callback(() => updating_open = false);
			}

			if (!updating_shouldSubmitOnEnter && dirty & /*closeOnEnter*/ 16) {
				updating_shouldSubmitOnEnter = true;
				modal_changes.shouldSubmitOnEnter = /*closeOnEnter*/ ctx[4];
				add_flush_callback(() => updating_shouldSubmitOnEnter = false);
			}

			modal.$set(modal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(t);
			destroy_component(modal, detaching);
		}
	};
}

function download(fileUrl, fileName) {
	let a = document.createElement("a");
	a.href = fileUrl;
	a.setAttribute("download", fileName);
	a.click();
}

function instance($$self, $$props, $$invalidate) {
	let $runs;
	let $activeRunId;
	let $connected;
	component_subscribe($$self, runs, $$value => $$invalidate(5, $runs = $$value));
	component_subscribe($$self, activeRunId, $$value => $$invalidate(11, $activeRunId = $$value));
	component_subscribe($$self, connected, $$value => $$invalidate(6, $connected = $$value));
	let editOpen = false;
	let editId = "";
	let editCache;
	let wereChangesMade = false;
	let closeOnEnter = true;

	function changesMade() {
		$$invalidate(3, wereChangesMade = true);
	}

	const headers = [
		{ key: "meta.name", value: "Name" },
		{ key: "type", value: "Type" },
		{ key: "size", value: "Size" },
		{ key: "overflow", empty: true }
	];

	function editRun(id) {
		$$invalidate(1, editOpen = true);
		editId = id;
		$$invalidate(2, editCache = cloneDeep($runs?.find(r => r.id === id)));
		$$invalidate(4, closeOnEnter = true);
	}

	function applyEdits() {
		setRunMetadata(editId, editCache.meta);
		$$invalidate(1, editOpen = false);
	}

	let selectedRowIds;
	const click_handler = row => editRun(row.id);
	const click_handler_1 = row => download(`${config.apiUrl}/csv/${row.id}`, row.name + ".csv");
	const click_handler_2 = row => deleteRun(row.id);

	function datatable_selectedRowIds_binding(value) {
		selectedRowIds = value;
		($$invalidate(0, selectedRowIds), $$invalidate(11, $activeRunId));
	}

	const click_row_handler = e => activateRun(e.detail.id);

	function textinput_value_binding(value) {
		if ($$self.$$.not_equal(editCache.meta.name, value)) {
			editCache.meta.name = value;
			$$invalidate(2, editCache);
		}
	}

	function textarea_value_binding(value) {
		if ($$self.$$.not_equal(editCache.meta.description, value)) {
			editCache.meta.description = value;
			$$invalidate(2, editCache);
		}
	}

	const focus_handler = () => $$invalidate(4, closeOnEnter = false);
	const blur_handler = () => $$invalidate(4, closeOnEnter = true);

	function modal_open_binding(value) {
		editOpen = value;
		$$invalidate(1, editOpen);
	}

	function modal_shouldSubmitOnEnter_binding(value) {
		closeOnEnter = value;
		$$invalidate(4, closeOnEnter);
	}

	const click_button_secondary_handler = () => $$invalidate(1, editOpen = false);

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$activeRunId*/ 2048) {
			$: $$invalidate(0, selectedRowIds = [$activeRunId]);
		}

		if ($$self.$$.dirty & /*selectedRowIds*/ 1) {
			$: activateRun(selectedRowIds[0]);
		}
	};

	return [
		selectedRowIds,
		editOpen,
		editCache,
		wereChangesMade,
		closeOnEnter,
		$runs,
		$connected,
		changesMade,
		headers,
		editRun,
		applyEdits,
		$activeRunId,
		click_handler,
		click_handler_1,
		click_handler_2,
		datatable_selectedRowIds_binding,
		click_row_handler,
		textinput_value_binding,
		textarea_value_binding,
		focus_handler,
		blur_handler,
		modal_open_binding,
		modal_shouldSubmitOnEnter_binding,
		click_button_secondary_handler
	];
}

class RunPage extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default RunPage;