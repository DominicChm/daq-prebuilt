import './DrivenTimeline.svelte.css.proxy.js';
/* src\Components\DrivenTimeline.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	check_outros,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	group_outros,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "../../_snowpack/pkg/svelte/internal.js";

import Timeline from "./Timeline.svelte.js";
import { pause, play, resetPlayback, seekTo, stop } from "../api.js";

import {
	activeRun,
	connected,
	currentTime,
	isStored,
	playing,
	playState
} from "../stores.js";

import { Button } from "../../_snowpack/pkg/carbon-components-svelte.js";
import Play32 from "../../_snowpack/pkg/carbon-icons-svelte/lib/Play32.js";
import Pause32 from "../../_snowpack/pkg/carbon-icons-svelte/lib/Pause32.js";
import Stop32 from "../../_snowpack/pkg/carbon-icons-svelte/lib/Stop32.js";

function create_if_block_3(ctx) {
	let button;
	let current;

	button = new Button({
			props: { icon: Pause32, kind: "primary" }
		});

	button.$on("click", pause);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (42:42) 
function create_if_block_2(ctx) {
	let button;
	let current;
	button = new Button({ props: { icon: Play32, kind: "primary" } });
	button.$on("click", play);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (40:4) {#if ($playing == null || !$connected)}
function create_if_block_1(ctx) {
	let button;
	let current;
	button = new Button({ props: { skeleton: true } });

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (52:4) {#if ($isStored)}
function create_if_block(ctx) {
	let button;
	let current;

	button = new Button({
			props: { icon: Stop32, kind: "secondary" }
		});

	button.$on("click", resetPlayback);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t0;
	let timeline;
	let updating_center;
	let t1;
	let current;
	const if_block_creators = [create_if_block_1, create_if_block_2, create_if_block_3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$playing*/ ctx[3] == null || !/*$connected*/ ctx[4]) return 0;
		if (!/*$playing*/ ctx[3] && /*showControls*/ ctx[0]) return 1;
		if (/*showControls*/ ctx[0]) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	function timeline_center_binding(value) {
		/*timeline_center_binding*/ ctx[10](value);
	}

	let timeline_props = {
		dragDisabled: /*$activeRun*/ ctx[5]?.type === "realtime",
		dataStart: "0"
	};

	if (/*center*/ ctx[2] !== void 0) {
		timeline_props.center = /*center*/ ctx[2];
	}

	timeline = new Timeline({ props: timeline_props });
	binding_callbacks.push(() => bind(timeline, 'center', timeline_center_binding));
	timeline.$on("dragstart", /*onDragStart*/ ctx[7]);
	timeline.$on("dragend", /*dragend_handler*/ ctx[11]);
	let if_block1 = /*$isStored*/ ctx[6] && create_if_block(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			create_component(timeline.$$.fragment);
			t1 = space();
			if (if_block1) if_block1.c();
			attr(div, "class", "root svelte-6vopt8");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div, null);
			}

			append(div, t0);
			mount_component(timeline, div, null);
			append(div, t1);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block0) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				} else {
					if_block0 = null;
				}
			}

			const timeline_changes = {};
			if (dirty & /*$activeRun*/ 32) timeline_changes.dragDisabled = /*$activeRun*/ ctx[5]?.type === "realtime";

			if (!updating_center && dirty & /*center*/ 4) {
				updating_center = true;
				timeline_changes.center = /*center*/ ctx[2];
				add_flush_callback(() => updating_center = false);
			}

			timeline.$set(timeline_changes);

			if (/*$isStored*/ ctx[6]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*$isStored*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(timeline.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(timeline.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			destroy_component(timeline);
			if (if_block1) if_block1.d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $playing;
	let $currentTime;
	let $connected;
	let $activeRun;
	let $isStored;
	component_subscribe($$self, playing, $$value => $$invalidate(3, $playing = $$value));
	component_subscribe($$self, currentTime, $$value => $$invalidate(9, $currentTime = $$value));
	component_subscribe($$self, connected, $$value => $$invalidate(4, $connected = $$value));
	component_subscribe($$self, activeRun, $$value => $$invalidate(5, $activeRun = $$value));
	component_subscribe($$self, isStored, $$value => $$invalidate(6, $isStored = $$value));
	let { showControls = true } = $$props;
	let dragging = false;
	let playingPreDrag = false;
	let center = 0;

	function onDragStart() {
		$$invalidate(8, playingPreDrag = $playing);
		$$invalidate(1, dragging = true);
	}

	function timeline_center_binding(value) {
		center = value;
		(($$invalidate(2, center), $$invalidate(1, dragging)), $$invalidate(9, $currentTime));
	}

	const dragend_handler = () => $$invalidate(1, dragging = false);

	$$self.$$set = $$props => {
		if ('showControls' in $$props) $$invalidate(0, showControls = $$props.showControls);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*dragging, $currentTime*/ 514) {
			$: if (!dragging) {
				$$invalidate(2, center = ($currentTime ?? 0) / 1000);
			}
		}

		if ($$self.$$.dirty & /*dragging, center, playingPreDrag*/ 262) {
			$: if (dragging) {
				seekTo(center * 1000);
				if (playingPreDrag) play();
			}
		}
	};

	return [
		showControls,
		dragging,
		center,
		$playing,
		$connected,
		$activeRun,
		$isStored,
		onDragStart,
		playingPreDrag,
		$currentTime,
		timeline_center_binding,
		dragend_handler
	];
}

class DrivenTimeline extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { showControls: 0 });
	}
}

export default DrivenTimeline;