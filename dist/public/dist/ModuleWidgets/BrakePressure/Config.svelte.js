/* src\ModuleWidgets\BrakePressure\Config.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	add_flush_callback,
	bind,
	binding_callbacks,
	bubble,
	create_component,
	destroy_component,
	detach,
	init,
	insert,
	mount_component,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "../../../_snowpack/pkg/svelte/internal.js";

import { FormGroup, NumberInput } from "../../../_snowpack/pkg/carbon-components-svelte.js";

function create_default_slot_2(ctx) {
	let numberinput;
	let updating_value;
	let current;

	function numberinput_value_binding(value) {
		/*numberinput_value_binding*/ ctx[1](value);
	}

	let numberinput_props = {
		label: "(CAL) Analog 0",
		helperText: "The analog reading that corresponds to 0 pressure"
	};

	if (/*config*/ ctx[0].minVoltage !== void 0) {
		numberinput_props.value = /*config*/ ctx[0].minVoltage;
	}

	numberinput = new NumberInput({ props: numberinput_props });
	binding_callbacks.push(() => bind(numberinput, 'value', numberinput_value_binding));
	numberinput.$on("input", /*input_handler*/ ctx[2]);

	return {
		c() {
			create_component(numberinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(numberinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const numberinput_changes = {};

			if (!updating_value && dirty & /*config*/ 1) {
				updating_value = true;
				numberinput_changes.value = /*config*/ ctx[0].minVoltage;
				add_flush_callback(() => updating_value = false);
			}

			numberinput.$set(numberinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(numberinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(numberinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(numberinput, detaching);
		}
	};
}

// (16:0) <FormGroup>
function create_default_slot_1(ctx) {
	let numberinput;
	let updating_value;
	let current;

	function numberinput_value_binding_1(value) {
		/*numberinput_value_binding_1*/ ctx[3](value);
	}

	let numberinput_props = {
		label: "(CAL) Psi per reading",
		helperText: "Number of PSI per analog reading tick"
	};

	if (/*config*/ ctx[0].psiPerVolt !== void 0) {
		numberinput_props.value = /*config*/ ctx[0].psiPerVolt;
	}

	numberinput = new NumberInput({ props: numberinput_props });
	binding_callbacks.push(() => bind(numberinput, 'value', numberinput_value_binding_1));
	numberinput.$on("input", /*input_handler_1*/ ctx[4]);

	return {
		c() {
			create_component(numberinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(numberinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const numberinput_changes = {};

			if (!updating_value && dirty & /*config*/ 1) {
				updating_value = true;
				numberinput_changes.value = /*config*/ ctx[0].psiPerVolt;
				add_flush_callback(() => updating_value = false);
			}

			numberinput.$set(numberinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(numberinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(numberinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(numberinput, detaching);
		}
	};
}

// (25:0) <FormGroup>
function create_default_slot(ctx) {
	let numberinput;
	let updating_value;
	let current;

	function numberinput_value_binding_2(value) {
		/*numberinput_value_binding_2*/ ctx[5](value);
	}

	let numberinput_props = {
		label: "Replicated (test)",
		helperText: "Not a real field - just here to test data replication"
	};

	if (/*config*/ ctx[0].replicated !== void 0) {
		numberinput_props.value = /*config*/ ctx[0].replicated;
	}

	numberinput = new NumberInput({ props: numberinput_props });
	binding_callbacks.push(() => bind(numberinput, 'value', numberinput_value_binding_2));
	numberinput.$on("input", /*input_handler_2*/ ctx[6]);

	return {
		c() {
			create_component(numberinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(numberinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const numberinput_changes = {};

			if (!updating_value && dirty & /*config*/ 1) {
				updating_value = true;
				numberinput_changes.value = /*config*/ ctx[0].replicated;
				add_flush_callback(() => updating_value = false);
			}

			numberinput.$set(numberinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(numberinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(numberinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(numberinput, detaching);
		}
	};
}

function create_fragment(ctx) {
	let formgroup0;
	let t0;
	let formgroup1;
	let t1;
	let formgroup2;
	let current;

	formgroup0 = new FormGroup({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	formgroup1 = new FormGroup({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	formgroup2 = new FormGroup({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(formgroup0.$$.fragment);
			t0 = space();
			create_component(formgroup1.$$.fragment);
			t1 = space();
			create_component(formgroup2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(formgroup0, target, anchor);
			insert(target, t0, anchor);
			mount_component(formgroup1, target, anchor);
			insert(target, t1, anchor);
			mount_component(formgroup2, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const formgroup0_changes = {};

			if (dirty & /*$$scope, config*/ 129) {
				formgroup0_changes.$$scope = { dirty, ctx };
			}

			formgroup0.$set(formgroup0_changes);
			const formgroup1_changes = {};

			if (dirty & /*$$scope, config*/ 129) {
				formgroup1_changes.$$scope = { dirty, ctx };
			}

			formgroup1.$set(formgroup1_changes);
			const formgroup2_changes = {};

			if (dirty & /*$$scope, config*/ 129) {
				formgroup2_changes.$$scope = { dirty, ctx };
			}

			formgroup2.$set(formgroup2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(formgroup0.$$.fragment, local);
			transition_in(formgroup1.$$.fragment, local);
			transition_in(formgroup2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(formgroup0.$$.fragment, local);
			transition_out(formgroup1.$$.fragment, local);
			transition_out(formgroup2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(formgroup0, detaching);
			if (detaching) detach(t0);
			destroy_component(formgroup1, detaching);
			if (detaching) detach(t1);
			destroy_component(formgroup2, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { config } = $$props;

	function numberinput_value_binding(value) {
		if ($$self.$$.not_equal(config.minVoltage, value)) {
			config.minVoltage = value;
			$$invalidate(0, config);
		}
	}

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function numberinput_value_binding_1(value) {
		if ($$self.$$.not_equal(config.psiPerVolt, value)) {
			config.psiPerVolt = value;
			$$invalidate(0, config);
		}
	}

	function input_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function numberinput_value_binding_2(value) {
		if ($$self.$$.not_equal(config.replicated, value)) {
			config.replicated = value;
			$$invalidate(0, config);
		}
	}

	function input_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('config' in $$props) $$invalidate(0, config = $$props.config);
	};

	return [
		config,
		numberinput_value_binding,
		input_handler,
		numberinput_value_binding_1,
		input_handler_1,
		numberinput_value_binding_2,
		input_handler_2
	];
}

class Config extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { config: 0 });
	}
}

export default Config;