/* src\ModuleWidgets\ModuleConfig.svelte generated by Svelte v3.46.4 */
import {
	SvelteComponent,
	add_flush_callback,
	bind,
	binding_callbacks,
	bubble,
	check_outros,
	create_component,
	destroy_component,
	detach,
	empty,
	group_outros,
	init,
	insert,
	mount_component,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "../../_snowpack/pkg/svelte/internal.js";

import brake_pressure from "./BrakePressure/Config.svelte.js";

import {
	ContentSwitcher,
	Form,
	FormGroup,
	Switch,
	TextArea,
	TextInput
} from "../../_snowpack/pkg/carbon-components-svelte.js";

function create_default_slot_4(ctx) {
	let switch0;
	let t0;
	let switch1;
	let t1;
	let switch2;
	let current;
	switch0 = new Switch({ props: { text: "General" } });

	switch1 = new Switch({
			props: {
				text: "Config",
				disabled: !/*typeMap*/ ctx[3][/*typename*/ ctx[1]]
			}
		});

	switch2 = new Switch({ props: { text: "Advanced" } });

	return {
		c() {
			create_component(switch0.$$.fragment);
			t0 = space();
			create_component(switch1.$$.fragment);
			t1 = space();
			create_component(switch2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(switch0, target, anchor);
			insert(target, t0, anchor);
			mount_component(switch1, target, anchor);
			insert(target, t1, anchor);
			mount_component(switch2, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch1_changes = {};
			if (dirty & /*typename*/ 2) switch1_changes.disabled = !/*typeMap*/ ctx[3][/*typename*/ ctx[1]];
			switch1.$set(switch1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(switch0.$$.fragment, local);
			transition_in(switch1.$$.fragment, local);
			transition_in(switch2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(switch0.$$.fragment, local);
			transition_out(switch1.$$.fragment, local);
			transition_out(switch2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(switch0, detaching);
			if (detaching) detach(t0);
			destroy_component(switch1, detaching);
			if (detaching) detach(t1);
			destroy_component(switch2, detaching);
		}
	};
}

// (60:30) 
function create_if_block_2(ctx) {
	let formgroup;
	let current;

	formgroup = new FormGroup({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(formgroup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(formgroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const formgroup_changes = {};

			if (dirty & /*$$scope, definition*/ 262145) {
				formgroup_changes.$$scope = { dirty, ctx };
			}

			formgroup.$set(formgroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(formgroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(formgroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(formgroup, detaching);
		}
	};
}

// (58:30) 
function create_if_block_1(ctx) {
	let switch_instance;
	let updating_config;
	let switch_instance_anchor;
	let current;

	function switch_instance_config_binding(value) {
		/*switch_instance_config_binding*/ ctx[15](value);
	}

	var switch_value = /*typeMap*/ ctx[3][/*typename*/ ctx[1]];

	function switch_props(ctx) {
		let switch_instance_props = {};

		if (/*definition*/ ctx[0].config !== void 0) {
			switch_instance_props.config = /*definition*/ ctx[0].config;
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		binding_callbacks.push(() => bind(switch_instance, 'config', switch_instance_config_binding));
		switch_instance.$on("input", /*input_handler_4*/ ctx[16]);
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = {};

			if (!updating_config && dirty & /*definition*/ 1) {
				updating_config = true;
				switch_instance_changes.config = /*definition*/ ctx[0].config;
				add_flush_callback(() => updating_config = false);
			}

			if (switch_value !== (switch_value = /*typeMap*/ ctx[3][/*typename*/ ctx[1]])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					binding_callbacks.push(() => bind(switch_instance, 'config', switch_instance_config_binding));
					switch_instance.$on("input", /*input_handler_4*/ ctx[16]);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (31:0) {#if selectedIndex === 0}
function create_if_block(ctx) {
	let form;
	let current;

	form = new Form({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(form.$$.fragment);
		},
		m(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const form_changes = {};

			if (dirty & /*$$scope, definition*/ 262145) {
				form_changes.$$scope = { dirty, ctx };
			}

			form.$set(form_changes);
		},
		i(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(form, detaching);
		}
	};
}

// (61:4) <FormGroup>
function create_default_slot_3(ctx) {
	let textinput;
	let current;

	textinput = new TextInput({
			props: {
				labelText: "Type Hash",
				value: "0x" + decimalToHexString(/*definition*/ ctx[0].config.typeNameHash),
				disabled: true
			}
		});

	textinput.$on("input", /*input_handler_5*/ ctx[17]);

	return {
		c() {
			create_component(textinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textinput_changes = {};
			if (dirty & /*definition*/ 1) textinput_changes.value = "0x" + decimalToHexString(/*definition*/ ctx[0].config.typeNameHash);
			textinput.$set(textinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textinput, detaching);
		}
	};
}

// (33:8) <FormGroup>
function create_default_slot_2(ctx) {
	let textinput;
	let updating_value;
	let t;
	let textarea;
	let updating_value_1;
	let current;

	function textinput_value_binding(value) {
		/*textinput_value_binding*/ ctx[5](value);
	}

	let textinput_props = { labelText: "Name" };

	if (/*definition*/ ctx[0].name !== void 0) {
		textinput_props.value = /*definition*/ ctx[0].name;
	}

	textinput = new TextInput({ props: textinput_props });
	binding_callbacks.push(() => bind(textinput, 'value', textinput_value_binding));
	textinput.$on("input", /*input_handler*/ ctx[6]);

	function textarea_value_binding(value) {
		/*textarea_value_binding*/ ctx[7](value);
	}

	let textarea_props = { labelText: "Description" };

	if (/*definition*/ ctx[0].description !== void 0) {
		textarea_props.value = /*definition*/ ctx[0].description;
	}

	textarea = new TextArea({ props: textarea_props });
	binding_callbacks.push(() => bind(textarea, 'value', textarea_value_binding));
	textarea.$on("input", /*input_handler_1*/ ctx[8]);
	textarea.$on("focus", /*focus_handler*/ ctx[9]);
	textarea.$on("blur", /*blur_handler*/ ctx[10]);

	return {
		c() {
			create_component(textinput.$$.fragment);
			t = space();
			create_component(textarea.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textinput, target, anchor);
			insert(target, t, anchor);
			mount_component(textarea, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textinput_changes = {};

			if (!updating_value && dirty & /*definition*/ 1) {
				updating_value = true;
				textinput_changes.value = /*definition*/ ctx[0].name;
				add_flush_callback(() => updating_value = false);
			}

			textinput.$set(textinput_changes);
			const textarea_changes = {};

			if (!updating_value_1 && dirty & /*definition*/ 1) {
				updating_value_1 = true;
				textarea_changes.value = /*definition*/ ctx[0].description;
				add_flush_callback(() => updating_value_1 = false);
			}

			textarea.$set(textarea_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textinput.$$.fragment, local);
			transition_in(textarea.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textinput.$$.fragment, local);
			transition_out(textarea.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textinput, detaching);
			if (detaching) detach(t);
			destroy_component(textarea, detaching);
		}
	};
}

// (47:8) <FormGroup style="display:flex; flex-direction: row; gap: 1rem">
function create_default_slot_1(ctx) {
	let textinput0;
	let updating_value;
	let t;
	let textinput1;
	let updating_value_1;
	let current;

	function textinput0_value_binding(value) {
		/*textinput0_value_binding*/ ctx[11](value);
	}

	let textinput0_props = { labelText: "MAC Address" };

	if (/*definition*/ ctx[0].mac !== void 0) {
		textinput0_props.value = /*definition*/ ctx[0].mac;
	}

	textinput0 = new TextInput({ props: textinput0_props });
	binding_callbacks.push(() => bind(textinput0, 'value', textinput0_value_binding));
	textinput0.$on("input", /*input_handler_2*/ ctx[12]);

	function textinput1_value_binding(value) {
		/*textinput1_value_binding*/ ctx[13](value);
	}

	let textinput1_props = { labelText: "Type" };

	if (/*definition*/ ctx[0].type !== void 0) {
		textinput1_props.value = /*definition*/ ctx[0].type;
	}

	textinput1 = new TextInput({ props: textinput1_props });
	binding_callbacks.push(() => bind(textinput1, 'value', textinput1_value_binding));
	textinput1.$on("input", /*input_handler_3*/ ctx[14]);

	return {
		c() {
			create_component(textinput0.$$.fragment);
			t = space();
			create_component(textinput1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textinput0, target, anchor);
			insert(target, t, anchor);
			mount_component(textinput1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textinput0_changes = {};

			if (!updating_value && dirty & /*definition*/ 1) {
				updating_value = true;
				textinput0_changes.value = /*definition*/ ctx[0].mac;
				add_flush_callback(() => updating_value = false);
			}

			textinput0.$set(textinput0_changes);
			const textinput1_changes = {};

			if (!updating_value_1 && dirty & /*definition*/ 1) {
				updating_value_1 = true;
				textinput1_changes.value = /*definition*/ ctx[0].type;
				add_flush_callback(() => updating_value_1 = false);
			}

			textinput1.$set(textinput1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textinput0.$$.fragment, local);
			transition_in(textinput1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textinput0.$$.fragment, local);
			transition_out(textinput1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textinput0, detaching);
			if (detaching) detach(t);
			destroy_component(textinput1, detaching);
		}
	};
}

// (32:4) <Form>
function create_default_slot(ctx) {
	let formgroup0;
	let t;
	let formgroup1;
	let current;

	formgroup0 = new FormGroup({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	formgroup1 = new FormGroup({
			props: {
				style: "display:flex; flex-direction: row; gap: 1rem",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(formgroup0.$$.fragment);
			t = space();
			create_component(formgroup1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(formgroup0, target, anchor);
			insert(target, t, anchor);
			mount_component(formgroup1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const formgroup0_changes = {};

			if (dirty & /*$$scope, definition*/ 262145) {
				formgroup0_changes.$$scope = { dirty, ctx };
			}

			formgroup0.$set(formgroup0_changes);
			const formgroup1_changes = {};

			if (dirty & /*$$scope, definition*/ 262145) {
				formgroup1_changes.$$scope = { dirty, ctx };
			}

			formgroup1.$set(formgroup1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(formgroup0.$$.fragment, local);
			transition_in(formgroup1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(formgroup0.$$.fragment, local);
			transition_out(formgroup1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(formgroup0, detaching);
			if (detaching) detach(t);
			destroy_component(formgroup1, detaching);
		}
	};
}

function create_fragment(ctx) {
	let contentswitcher;
	let updating_selectedIndex;
	let t;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	function contentswitcher_selectedIndex_binding(value) {
		/*contentswitcher_selectedIndex_binding*/ ctx[4](value);
	}

	let contentswitcher_props = {
		style: "margin-bottom: 1rem",
		$$slots: { default: [create_default_slot_4] },
		$$scope: { ctx }
	};

	if (/*selectedIndex*/ ctx[2] !== void 0) {
		contentswitcher_props.selectedIndex = /*selectedIndex*/ ctx[2];
	}

	contentswitcher = new ContentSwitcher({ props: contentswitcher_props });
	binding_callbacks.push(() => bind(contentswitcher, 'selectedIndex', contentswitcher_selectedIndex_binding));
	const if_block_creators = [create_if_block, create_if_block_1, create_if_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*selectedIndex*/ ctx[2] === 0) return 0;
		if (/*selectedIndex*/ ctx[2] === 1) return 1;
		if (/*selectedIndex*/ ctx[2] === 2) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			create_component(contentswitcher.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(contentswitcher, target, anchor);
			insert(target, t, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const contentswitcher_changes = {};

			if (dirty & /*$$scope, typename*/ 262146) {
				contentswitcher_changes.$$scope = { dirty, ctx };
			}

			if (!updating_selectedIndex && dirty & /*selectedIndex*/ 4) {
				updating_selectedIndex = true;
				contentswitcher_changes.selectedIndex = /*selectedIndex*/ ctx[2];
				add_flush_callback(() => updating_selectedIndex = false);
			}

			contentswitcher.$set(contentswitcher_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(contentswitcher.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(contentswitcher.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(contentswitcher, detaching);
			if (detaching) detach(t);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

function decimalToHexString(number) {
	if (number < 0) {
		number = 0xFFFFFFFF + number + 1;
	}

	return number.toString(16).toUpperCase();
}

function instance($$self, $$props, $$invalidate) {
	let { typename } = $$props;
	let { definition } = $$props;
	let selectedIndex = 0;
	const typeMap = { brake_pressure };

	function contentswitcher_selectedIndex_binding(value) {
		selectedIndex = value;
		$$invalidate(2, selectedIndex);
	}

	function textinput_value_binding(value) {
		if ($$self.$$.not_equal(definition.name, value)) {
			definition.name = value;
			$$invalidate(0, definition);
		}
	}

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function textarea_value_binding(value) {
		if ($$self.$$.not_equal(definition.description, value)) {
			definition.description = value;
			$$invalidate(0, definition);
		}
	}

	function input_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function textinput0_value_binding(value) {
		if ($$self.$$.not_equal(definition.mac, value)) {
			definition.mac = value;
			$$invalidate(0, definition);
		}
	}

	function input_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function textinput1_value_binding(value) {
		if ($$self.$$.not_equal(definition.type, value)) {
			definition.type = value;
			$$invalidate(0, definition);
		}
	}

	function input_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function switch_instance_config_binding(value) {
		if ($$self.$$.not_equal(definition.config, value)) {
			definition.config = value;
			$$invalidate(0, definition);
		}
	}

	function input_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('typename' in $$props) $$invalidate(1, typename = $$props.typename);
		if ('definition' in $$props) $$invalidate(0, definition = $$props.definition);
	};

	return [
		definition,
		typename,
		selectedIndex,
		typeMap,
		contentswitcher_selectedIndex_binding,
		textinput_value_binding,
		input_handler,
		textarea_value_binding,
		input_handler_1,
		focus_handler,
		blur_handler,
		textinput0_value_binding,
		input_handler_2,
		textinput1_value_binding,
		input_handler_3,
		switch_instance_config_binding,
		input_handler_4,
		input_handler_5
	];
}

class ModuleConfig extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { typename: 1, definition: 0 });
	}
}

export default ModuleConfig;